{"comment_text": "Ok, yeah sorry the docs other than the tutorial assume some familiarity with Haskell.<p>2. What do you mean by &quot;verification IP&quot;? It was that phrase that made me mention testbenches.<p>Basically, while CLaSH is hard coded to understand certain types such as the Signal type, almost all primitive function are just defined with Verilog&#x2F;VHDL templates which it instantiates. One can write their own templates that work just the same way. So for any piece of CLaSH-compilable Haskell, you get VHDL&#x2F;Verilog for free, and for any bit of piece of VHDL&#x2F;Verilog, you can use it in CLaSH by writing some Haskell (with the same ports, and that hopefully does the same thing) and then telling CLaSH the Haskell is to be replaced with your Verilog&#x2F;VHDL.<p>This is about as good bidirectional comparability as one can get. Automatic Verilog&#x2F;VHDL -&gt; CLaSH compilation would be an improvement, but I don&#x27;t think it is possible: I&#x27;m not sure to what degree the semantics of Verilog&#x2F;VHDL are formalized, and even if they are, there&#x27;s no way the implementations all respect those semantics.<p>The testbench functions are just templated like any other primitive function.<p>1.\nUnsafeSynchronizer &quot;casts&quot; one signal to another -- it&#x27;s compiled to a plain net in Verilog&#x2F;VHDL. At each output cycle, n, it looks at the round(n*fin&#x2F;fout) input cycle and give it that value.<p>Obviously this is unsafe because, as you say, in the real world the problem is asynchronous. You don&#x27;t know the exact frequency ratios and phase differences, nor are they constant, and even if you did you&#x27;d get subtle timing errors with an incoming value that doesn&#x27;t change on the clock edge.<p>The trick is it is a pretty basic &quot;black box&quot; to augment CLaSH with, so proper synthesizers can be written in pure CLaSH. if that&#x27;s not enough for some super-asynchronous synchronizer design, one can always fall back on writing their own black-box as described above.<p>------------------------------------------------------------------------------------------------------------<p>I don&#x27;t think anyone imagines that CLaSH will be immediately understandable to someone who has never used Haskell. So no way does anyone expect the benefits will be immediately clear. So are you saying the restrictions I mention sound too onerous, or are you saying &quot;I dunno, it looks weird&quot;?<p>If the former, that&#x27;s perfectly acceptable, thank you for reading.<p>If the latter, I&#x27;m sorry but this is a pet peeve of mine--we get this a lot in the function programming community. Understand that we are claiming the benefits are worth the non-trivial learning curve. If it was so damn obvious, it couldn&#x27;t offer much benefit over the status quo---people would have already switched en mass and it would be the status quo.<p>While C-esque cuteness looks nice, I agree such things are doomed to failure. The C model is easy enough to stand, but it&#x27;s linearity, implicit state, and notion of control flow have nothing to do with the hardware---you can understand both models, but the compilation process is necessarily non-trivial and sufficiently &quot;far from subjective&quot; that many designs cannot be expressed at all, and many more must be expressed through very round about means.<p>Functional HDLs like CLaSH have a dead-simple structural compilation model, so while they may not understand every circuit, they can express it---the compiler is near subjective but not homomorphic counting these like this SR flip-flop:<p><pre><code>  \\ r s -&gt; let q  = nor r q&#x27;\n               q&#x27; = nor s q\n           in (q, q&#x27;)\n</code></pre>\nThis compiles to exactly what it looks like, but diverges (i.e. infinite loops) under Haskell&#x27;s semantics.<p>Lastly here is a comparison of writing the same project twice (though the paper is done by the CLaSH designers) <a href=\"http:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;Jan_Kuper&#x2F;publication&#x2F;47936996_Comparing_CaSH_and_VHDL_by_implementing_a_dataflow_processor&#x2F;links&#x2F;02e7e520c06378cdbd000000.pdf?origin=publication_detail\" rel=\"nofollow\">http:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;Jan_Kuper&#x2F;publication&#x2F;47...</a>", "author": "Ericson2314", "title": null, "url": null, "timestamp": 1431288136, "created_at": "2015-05-10T20:02:16.000Z", "comment_id": "9521118", "parent_id": 9519566, "story_title": "C\u03bbaSH \u2013 From Haskell to Hardware", "story_id": 9516217, "story_url": "http://www.clash-lang.org/", "points": null}