{"comment_text": "I worked on a 68K emulator that supported heap tagging, so you could:<p>- detect multiple frees of the same memory, even when pointers had been returned by subsequent allocation calls (e.g., alloc =&gt; A, free(A), alloc =&gt; A&#x27;, free(A) would trap, where A and A&#x27; have the same program-observable values)<p>- trap reads and writes to free&#x27;d memory, even if the memory had been subsequently re-allocated<p>- do strong bounds checking (can&#x27;t read or write heap block B with an offset of a pointer to A, even if you computed a valid address in B)<p>- trap reads of uninitialized memory (you <i>did</i> mean to zero that buffer you allocated, right?), clear down to &quot;that read of 32 bits included 8 bits that weren&#x27;t initialized, did you mean that?&quot;<p>It wasn&#x27;t perfect (you could do pointer arithmetic and smuggling operations that foiled the tagging), but we found some nice bugs with it.<p>You can approach this with MMU games, but tagging all your values is more powerful.", "author": "kabdib", "title": null, "url": null, "timestamp": 1431288287, "created_at": "2015-05-10T20:04:47.000Z", "comment_id": "9521123", "parent_id": 9519812, "story_title": "Beyond the PDP-11: Processor support for a memory-safe C abstract machine [pdf]", "story_id": 9519812, "story_url": "http://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/201503-asplos2015-cheri-cmachine.pdf", "points": null}