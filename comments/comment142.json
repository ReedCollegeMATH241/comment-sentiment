{"comment_text": "They built a custom CPU on an FPGA that is memory-safe for widely used C undefined behavior.  They still need &quot;fat pointers&quot;; this doesn&#x27;t let them run existing executables, or anything close to them.  It&#x27;s neat that they were able to do this.  It&#x27;s painful that they had to.<p>The &quot;container&quot;&#x2F;&quot;offsetof&quot; problem is strange.  If you only have a pointer to a member of a struct, you don&#x27;t really know the type of the containing struct.  You don&#x27;t even know if there <i>is</i> a containing struct.  &quot;offsetof&quot; implies an unchecked cast, violating type checking. Why is that used anywhere, let alone in the Linux kernel? (In decades of C&#x2F;C++ programming, I never wanted to do that.)<p>This is why I really hope Rust can replace C. (As I write occasionally, &quot;Rust guys, please don&#x27;t screw it up&quot;.) Rust is complicated, but it&#x27;s simpler than the semantics of C undefined behavior.  That may be the answer to use on C programmers who think Rust is too complicated. All those little issues in C, such as &quot;can you dereference the element one past the end of the array&quot; and &quot;after dereferencing, what happens if you then test for a null pointer&quot; require a good understanding of the machine model and how an optimizing compiler works.", "author": "Animats", "title": null, "url": null, "timestamp": 1431288614, "created_at": "2015-05-10T20:10:14.000Z", "comment_id": "9521138", "parent_id": 9519812, "story_title": "Beyond the PDP-11: Processor support for a memory-safe C abstract machine [pdf]", "story_id": 9519812, "story_url": "http://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/201503-asplos2015-cheri-cmachine.pdf", "points": null}